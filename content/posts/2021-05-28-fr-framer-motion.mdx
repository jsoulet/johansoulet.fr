---
date: '2021-05-28'
title: "Comment animer un composant React √† l'aide de la librairie Motion ?"
featuredImage: '../images/2021-05-28-framer-motion/roller-coaster.jpeg'
lang: fr
i18n:
  - locale: en
    slug: /2021-05-28-en-framer-motion

---

import Card0 from './2021-05-28-framer-motion/Card0.tsx'
import Card1 from './2021-05-28-framer-motion/Card1.tsx'
import Card2 from './2021-05-28-framer-motion/Card2.tsx'
import Card3 from './2021-05-28-framer-motion/Card3.tsx'
import Card4 from './2021-05-28-framer-motion/Card4.tsx'

export const cardProps = {
  image: "https://picsum.photos/id/442/1909/1262",
  title: "Geo-caching",
  category: "urban",
  price: "‚Ç¨",
  desc: "Get involved into an immersive treasure hunt to discover the hidden places of the city. You'll learn a lot, from historical gossips to hidden street art masterpieces. Suitable for children, groups, families... ",
}

<Image align="right" caption="Photo par Kevin Jarrett sur Unsplash">

![](../images/2021-05-28-framer-motion/roller-coaster.jpeg)

</Image>

Depuis quelques ann√©es, les micro-animations ne sont plus r√©serv√©es uniquement aux applications mobiles natives et sont de plus en plus pr√©sentes dans les applications web. Parce qu'elles permettent d'accompagner l'internaute dans sa navigation ou de donner plus de profondeur au contenu, elles transforment une exp√©rience utilisateur "qui fait le taf" en une exp√©rience " qui fait wow". 

Quand j'ai essay√© de d√©velopper des animations nativement, en CSS et VanillaJS, sur des projets React, j'√©tais souvent bloqu√© par les m√™mes probl√®mes r√©currents : 

- Les animations d'entr√©e/sortie √©taient complexes √† mettre en place
- Beaucoup de code est dupliqu√© d'un composant √† l'autre
- L'ochestration des animations entre plusieurs composant est un cauchemards

Le r√©sultat n'√©tait pas fluide et ce n'√©tait pas du tout rentable compte tenu du temps que je devais passer dessus.

R√©cemment j'ai d√©couvert [Motion](https://www.framer.com/motion/), d√©velopp√©e par Framer, et m√™me si je n'ai pas encore eu l'occasion d'exp√©rimenter cette biblioth√®que √† son plein potentiel, elle a d√©j√† pu m'√¥ter quelques √©pines du pied. 

> üëâ Dans cet article, j'utiliserai comme illustration le composant Card ci dessous, le projet complet est quant √† lui accessible sur [CodeSandbox](https://codesandbox.io/s/clever-water-o8wzp?file=/src/Card.tsx)

```tsx
import { FC } from "react";
import styles from "./Card.module.scss";

interface CardProps {
  title: string;
  desc: string;
  category: string;
  price: string;
  image: string;
}

const Card: FC<CardProps> = ({ image, title, category, price, desc }) => {
  return (
    <div
      className={styles.card}
    >
      <img src={image} className={styles.image} alt="" />
      <div className={styles.content}>
        <h2 className={styles.title}>{title}</h2>
        <div className={styles.subtitle}>
          {price} ‚Ä¢ {category}
        </div>
        <div className={styles.desc}>{desc}</div>
      </div>
    </div>
  );
};

export default Card;
```

<Card0 {...cardProps}/>


## Animer un √©l√©ment HTML

Commencez par ajouter `framer-motion` √† votre projet.

```bash
yarn add framer-motion
```

Puis, importez Motion dans votre composant

```tsx
import { motion } from 'framer-motion'
```

Cet utilitaire vous donnera acc√®s aux composants Motion (ex : motion.div, motion.span, motion.path...), il y en a un pour chaque √©l√©ments HTML et SVG. Ils fonctionnent comme les √©l√©ments natifs, et peuvent en plus √™tre surcharg√©s avec des props propres √† Motion.

Les props `initial` et `animate` permettent de d√©finir l'√©tat initial du composant et les valeurs vers lesquelles il doit s'animer lorsque le composant est mont√©. 

Par d√©faut, Motion choisira proposera une transition adapt√©e aux propri√©t√©s qui sont anim√©es, mais il est bien entendu possible de la personnaliser.

```tsx
<motion.div
  className={styles.card}
  initial={{ opacity: 0, scale: 0.6 }}
  animate={{ opacity: 1, scale: 1 }}
  transition={{ type: "spring", bounce: 0.5 }}
>
	{/* ... */} 
</motion.div>
```

Pour permettre la r√©utilisabilit√© des animation,  Motion accepte aussi un objet variants qui d√©crit plusieurs animations. Les props `initial` et `animate` prendrons alors la clef de la variante √† utiliser.

```tsx
const bounceVariants = {
  hidden: { opacity: 0, scale: 0.6 },
  visible: {
    opacity: 1,
    scale: 1,
    transition: {
      type: "spring",
      bounce: 0.5
    }
  }
};

<motion.div
	className={styles.card}
	initial="hidden"
	animate="visible"
	variants={bounceVariants}
>
	{/* ... */} 
</motion.div>
```

<Card1 {...cardProps}/>


## Surcharger un  composant React pour l'animer

On vient de voir comment animer un √©l√©ment HTML, ce qui est tr√®s utile quand on a la main sur le code du composant. Or, le propre de React est de manipuler des composants r√©utilisables. Comment faire lorsque que celui que l'on souhaite animer est externe au projet, dans une librairie de composants (MaterialUI, Ant.design...) ou dans le design-system de votre organisation par exemple ?

Dans cette configuration, l'utilitaire `motion()` peut aussi √™tre utilis√© comme fonction afin d'encapsuler le composant. Comme les composants r√©unis dans `motion`, ce nouveau composant animable se comportera comme d'habitude et aura h√©rit√© des props des composants Motion. 

La surcharge des composants externes doit √™tre faite √† l'ext√©rieur de la fonction de render des composants parents.

```tsx
import { Button } from '@corp-designsystem/react'

const AnimatedButton = mount(Button)

const Card = () => {
	return <div className={styles.button}>
    <AnimatedButton
      initial="hidden"
      animate="visible"
      variants={fadeUpVariants}
    >
      Book
    </AnimatedButton>
  </div>
}
```

<Card2 {...cardProps}/>

*Les animations Motion sont jou√©es au montage du composant. Raffraichissez la page si vous n'avez pas eu le temps de la voir.*

> üí°  Cette m√©thode ne marchera que sur les composants qui ont transf√®rent la ref √† leur  racine √† l'aide de `React.forwardRef`. Si ce n'est pas le cas, une alternative pourrait √™tre d'encapsuler votre composant au sein d'un container `motion.div` , et c'est lui que vous animerez.

## Propager des animations en cascade sur un composant et ses enfants

Ce qu'on a fait jusque ici pouvait √™tre fait en quelques lignes sous condition de conna√Ætre les keyframes de CSS3. 

Pour pour animer les enfants de mani√®re coordonn√©es, il faudrait faire les calculs des d√©lais d'animation entre chaque composant. Si un composant Motion a des composants enfants, un changement dans la variante du parent sera propag√© dans la variante de l'enfant, √† condition que leurs identifiants soient les m√™mes. Gr√¢ce √† la propri√©t√© `transition`, on peut d√©finir les propri√©t√©es suppl√©mentaires pour orchester les animations entre elles

- *when*: d√©fini si le composant doit √™tre anim√© avant ses enfants (`beforeChildren`) ou apr√®s (`afterChildren`).
- *childrenDelay* : le temps entre l'animation du parent et le d√©but de l'animation des enfants
- *staggerChildren*: le temps de d√©lai entre chaque enfant
- *staggerDirection*: si staggerDirection vaut 1, les enfants seront anim√©s du premier au dernier dans l'ordre du DOM , du dernier au premier si elle vaut -1

Pour qu'elles puissent se synchroniser avec leur parent, les animations d√©finies dans l'objet variants doivent avoir les m√™mes clefs .

<Card3 {...cardProps}/>

*Raffraichissez la page si vous n'avez pas eu le temps de voir l'animation.*

## Contr√¥ler les animations de composants en fonctions de param√®tres ext√©rieurs

Pour le moment, les animations de la carte s'ex√©cutent au chargement du composant. S'il est plus bas dans la fen√™tre, l'animation se d√©clenchera quand m√™me et l'utilisateur ne pourra pas en profiter. On va alors chercher √† contr√¥ler l'animation √† l'aide de l'API Intersection Observer et du hook `useAnimation`.

```bash
yarn add react-intersection-observer
```

Au sein du composant, importer le hook `useInView` de react-intersection-observer et `useAnimation` de framer-motion.

`useInView` permet de savoir si l'√©l√©ment r√©f√©renc√© est visible dans l'√©cran

`useAnimation` renvoie un objet `controls` qui permet de lancer programatiquement des variates d'animation.

On utilise alors useEffect pour alterner entre les √©tats visible et hidden en fonction de la visiblit√© de la carte.

```bash
const Card: FC<CardProps> = ({ image, title, category, price, desc }) => {
  const { ref, inView } = useInView();
  const controls = useAnimation();
  useEffect(() => {
    if (inView) {
      controls.start("visible");
    }
    if (!inView) {
      controls.start("hidden");
    }
  }, [inView, controls]);
  return (
    <motion.div
      className={styles.card}
      initial="hidden"
      variants={bounceVariants}
      animate={controls}
      ref={ref}
    ></motion.div>)
}
```

<Card4 {...cardProps}/>

*Rejouez l'animation en scrollant, pour cacher/afficher la carte*

## Conclusion

Motion m'a permi de mettre en place une suite d'animations orchestr√©e relativement facilement, sans avoir √† calculer manuellement les intervalles entre chaque √©l√©ment parent et enfants.

Cette librairie regorge d'autres fonctionnalit√©s, comme les animations au d√©montage du DOM, des helpers pour animer au hover, focus ou clic, l'animation des SVG... En facilitant la cr√©ation d'animations fluides, [Motion](https://www.framer.com/motion/) √©largi le cercle des possibles et rend envisageables la cr√©ation d'une exp√©rience utilisateur vivante √† l'aide de micro-animations, m√™me sur des projets √† budget serr√©.