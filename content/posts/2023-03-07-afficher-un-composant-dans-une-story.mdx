---
date: '2023-03-07'
title: "Afficher un composant dans une story et en rendre ses arguments modifiables √† la vol√©e"
featuredImage: '../images/2023-02-storybook/knot.jpg'
lang: fr
i18n:
  - locale: en
    slug: /2023-03-07-display-a-component-story
chapo: "Dans ce deuxi√®me article de la s√©rie sur Storybook, c'est l'heure de mettre les mains dans le code pour d√©couvrir comment cr√©er concr√®tement une story √† l'aide du standard CSF-2 et en personnaliser les param√®tres pour qu'elle soit utilisables par toutes les parties prenantes de votre organisation."

---
L'objectif principal de Storybook est de cr√©er un catalogue de "stories" de composants. Chaque story repr√©sente le rendu d'un composant dans un de ses √©tats.

# Component Story Format : un standard ouvert pour √©crire des stories

Les impl√©mentations r√©centes des stories sont bas√©es sur un format ouvert et agnostique appel√© "Component Story Format", abr√©g√© CSF. M√™me si l'√©quipe principale de Storybook en est le principal contributeur, le fait qu'elle ne soit pas seule est encourageant. Cela signifie que nous pouvons r√©utiliser ce que nous avons d√©velopp√© au-del√† de Storybook, afin d'int√©grer les stories dans d'autres outils de la stack, comme Cypress ou Testing Library.

Cependant, malgr√© l'ouverture de CSF, d'autres environnements de d√©veloppement de composants ([Styleguidist](https://react-styleguidist.js.org/), [Docz](https://www.docz.site/), [React Cosmos](https://reactcosmos.org/)...) n'ont pas adopt√© le format. Ils ont pr√©f√©r√© leur propre format propri√©taire.

Essentiellement, le CSF fonctionne comme ceci : un export par d√©faut pour les m√©tadonn√©es, et un export pour chaque story du composant. Chaque story est une fonction qui renvoie un composant.

## Args sont les nouvelles props

Si vous venez du d√©veloppement React, vous avez probablement l'habitude d'utiliser `props` pour personnaliser le comportement ou l‚Äôaffichage d'un composant en fonction de donn√©es provenant de son parent.

Storybook a conserv√© cette logique, mais pour rester agnostique au framework, il l'a renomm√©e "arguments" (ou `args`). Les arguments sont d√©finis en tant que propri√©t√© de la fonction de story.

```tsx

export const WithoutName = () => <HelloWorld />
export const WithName = (args) => <HelloWorld {...args} />
WithName.args = {
	name: 'David'
}
```

Les arguments sont des objets JavaScript standards, vous pouvez donc d√©finir les valeurs par d√©faut de toutes les mani√®res imaginables par le langage. Les pratiques peuvent donc varier en fonction de la librairie de composants ou de l'√©quipe qui la maintient.

```tsx

// Default props as an external object
const DEFAULT_PROPS = {
	label: 'Click me'
	onClick: () => console.log('clicked')
}

export const Default = (args) => <Button {...args} />
Default.args = DEFAULT_PROPS

export const Disabled = (args) => <Button {...args} />
Disabled.args = {
	...DEFAULT_PROPS,
	disabled: true
}

export const WithEmojiLabel = (args) => <Button {...args} />
WithEmojiLabel.args = {
	...DEFAULT_PROPS,
	label: 'Click me üòé'
}

// ----------------------------------------
// Default props defined in the first story

export const Default = (args) => <Button {...args} />
Default.args = {
	label: 'Click me'
	onClick: () => console.log('clicked')
}

export const Disabled = (args) => <Button {...args} />
Disabled.args = {
	...Default.args,
	disabled: true
}

export const WithEmojiLabel = (args) => <Button {...args} />
WithEmojiLabel.args = {
	...Default.args,
	label: 'Click me üòé'
}
```

Bien qu'il existe diff√©rentes m√©thodes, je recommande d‚Äôen choisir une pour toutes les stories et de maintenir un code coh√©rent. Cela am√©liorera l'exp√©rience de d√©veloppement et facilitera les contributions.

Les recommendations conseillent d‚Äôutiliser les m√©tadonn√©es CSF pour stocker les propri√©t√©s par d√©faut. Storybook int√©grera automatiquement la propri√©t√© `args` √† partir des m√©tadonn√©es et surchargera la variante si sa propri√©t√© `args` est d√©finie.

```tsx
export default {
	args: {
		label: 'Click me'
		onClick: () => console.log('clicked')
  }
}

export const Default = (args) => <Button {...args} />
export const Disabled = (args) => <Button {...args} />
Disabled.args = {
	disable: true
}
export const WithEmojiLabel = (args) => <Button {...args} />
WithEmojiLabel.args = {
	label: 'Click me üòé'
}
```

## Un Template pour les gouverner tous

Le CSF est d√©claratif, mais √©crire une fonction diff√©rente pour chaque sc√©nario sera r√©p√©titif et difficile √† maintenir √† long terme. C'est pourquoi il est recommand√© de commencer par une story template qui sera dupliqu√©e et modifi√©e pour chaque sc√©nario.

```tsx
const Template = (args) => <Button {...args} />

const Default = Template.bind({})

const WithEmojiLabel = Template.bind({})
WithEmojiLabel.args = {
	label: 'Click me üòé'
}
```

Pour des variants simples, il semblera inutile de cr√©er et dupliquer une fonction de template. Cependant, d√®s que vous ajoutez des histoires plus complexes, il sera b√©n√©fique d‚Äôavoir un composant de base que vous pouvez personnaliser en fonction du sc√©nario que vous documentez.

De plus, n‚Äôoublions pas que l'√©quipe de d√©veloppement front-end n'est pas le seul utilisateur de Storybook. Les visiteurs pourront plus facilement comprendre comment interagir avec le composant si toutes ses story se ressemblent.

# Contr√¥ler les arguments pass√©s √† la story

Storybook b√©n√©ficie d'une interface utilisateur composable qui peut √™tre am√©lior√©e par une vari√©t√© d'add-ons. L'un des plus populaires s'appelle "Controls" : il offre un panneau additionnel o√π les arguments pass√©s √† la story peuvent √™tre √©dit√©s √† l'aide de champs de formulaire. Il facilite le processus de test en permettant √† tout visiteur de v√©rifier comment le composant se comporte dans de multiples situations.

L'add-on cr√©era automatiquement les champs de formulaire en fonction de la d√©finition des PropTypes (pour les composants JavaScript) et de l'interface Props (pour les composants TypeScript).

Par exemple :

- champ de texte pour les chaines de caract√®res
- toggle pour les bool√©ens
- boutons radio ou select pour les enums

<Image>

![La Story d‚Äôun bouton et addon Control](../images/2023-02-storybook/buttonstory.png)
_La Story d‚Äôun bouton et son addon Control_
</Image>

## Personnaliser les champs d'argument

En tant que d√©veloppeur de composants, la d√©finition automatique est tr√®s pratique, mais vous pouvez aller encore plus loin et personnaliser les champs pour optimiser l'exp√©rience de vos utilisateurs.

### Contr√¥ler les contr√¥les

Techniquement, chaque fichier de story recevra un param√®tre `argTypes`, dont la valeur est inf√©r√©e √† partir des props du composant. L'add-on Controls utilise cette valeur pour g√©n√©rer le formulaire. C'est pourquoi il est possible d'√©diter l'apparence du panneau Controls en modifiant les `argTypes`, au niveau du fichier ou de la story.

```tsx
export default {
	argTypes: {
		// some metadata
	},    
}

export Default = Template.bind({})
Default.argTypes = { /* other metadata */ }
```

### Filtrer les champs

Pour aller encore plus loin dans la personnalisation, vous pouvez √©diter les m√©tadonn√©es de l'add-on en utilisant le param√®tre `controls`. Pour une pr√©sentation compl√®te de ce qui est offert, je vous recommande de jeter un coup d'≈ìil √† la page de [documentation](https://storybook.js.org/docs/react/essentials/controls) sur le site de Storybook.

Les param√®tres que j'utilise le plus souvent sont `include` et `exclude`, qui filtrent les champs dans le panneau Controls. Ils sont utiles lorsque votre composant h√©rite de nombreuses props de son parent, mais que vous n'avez besoin de rendre modifiables que quelques props sp√©cifiques dans Storybook, ou que vous devez masquer tous les handlers d'√©v√©nements et callbacks.

```tsx
export default {
	title: 'Button',
	component: Button,
	{
		// *do not show the controls for props starting with "on"
		// usually onChange, onBlur, onSubmit...*
		{ controls: { exclude: /^on.*/ } }
	}
}

export Disabled = Template.bind({})
Disabled.parameters = {
		controls: {
			// the only control visible will be the one for the *"disabled"* props
			{ controls: { include: ['disabled'] } }
		}
	}
```

# Cr√©er des wrappers autour des composants

Il est rare que tous vos composants soient des fonctions parfaitement pures et re√ßoivent toutes leurs d√©pendances par injection de props. Les frameworks front-end modernes b√©n√©ficient souvent de l'injection de contexte pour am√©liorer l'exp√©rience du d√©veloppeur. Voici quelques exemples de contextes qui pourraient √™tre inject√©s :

- les donn√©es d'un store Redux
- le th√®me de styled-components
- les traductions du contexte i18n
- ...

Vous pouvez ajouter des wrappers de contexte autour des composants en utilisant la fonction de template, mais une approche plus propre consiste √† utiliser la propri√©t√© `decorators`.

De cette fa√ßon, la logique de la story est s√©par√©e de la logique du wrapper, ce qui augmente la lisibilit√© de la documentation et sa maintenabilit√©. Point bonus : avoir les conteneurs de contexte d√©clar√©s dans les d√©corateurs les rend plus faciles √† extraire dans des fichiers s√©par√©s pour une meilleure r√©utilisabilit√© √† travers l‚Äôensemble des stories de Storybook si n√©cessaire.

# Conclusion

Storybook est un catalogue de composants interactif qui peut √™tre utilis√© par des utilisateurs techniques et non techniques. Les d√©veloppeurs doivent √™tre en mesure de rechercher des composants existants et de comprendre rapidement comment ils sont cens√©s √™tre utilis√©s, tandis que les profils non techniques peuvent utiliser la sandbox pour v√©rifier ce qui a √©t√© d√©velopp√© par les ing√©nieurs et comment le composant peut √™tre adapt√© √† un nouveau contexte. Il est important que les stories soient explicites et faciles √† maintenir afin de servir ces utilisateurs.

Nous avons vu que le format de story par composant (CSF) est le format par d√©faut utilis√© pour d√©crire le comportement d'une histoire, mais saviez-vous que vous pouvez √©galement utiliser [Markdown](https://storybook.js.org/docs/react/api/mdx) pour plus de flexibilit√© dans la documentation ? La syntaxe CSF pr√©sent√©e dans cet article est la version 2.0. La version 3.0 a √©t√© annonc√©e l'ann√©e derni√®re et devrait r√©duire le code redondant et √©liminer le besoin de `Template.bind({})`. Personnellement, je suis impatient de l'adopter.